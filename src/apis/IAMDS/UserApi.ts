/* tslint:disable */
/* eslint-disable */
/**
 * foundation
 * Platform foundation consists of services on top of which the Avalara Compliance Cloud platform is built. These services are foundational and provide functionality such as common organization, tenant and user management for the rest of the compliance platform.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../../runtime';
import { RequestInit } from 'node-fetch';
import {
    TenantList,
    TenantListFromJSON,
    TenantListToJSON,
    User,
    UserFromJSON,
    UserToJSON,
    UserList,
    UserListFromJSON,
    UserListToJSON,
    VersionError,
    VersionErrorFromJSON,
    VersionErrorToJSON,
} from '../../packages/IAMDS';

export interface CreateUserRequest {
    avalaraVersion?: CreateUserAvalaraVersionEnum;
    xCorrelationId?: string;
    user?: User;
}

export interface DeleteUserRequest {
    userId: string;
    avalaraVersion?: DeleteUserAvalaraVersionEnum;
    xCorrelationId?: string;
    ifMatch?: string;
}

export interface GetUserRequest {
    userId: string;
    avalaraVersion?: GetUserAvalaraVersionEnum;
    xCorrelationId?: string;
    ifNoneMatch?: string;
}

export interface GetUserTenantsRequest {
    userId: string;
    $filter?: string;
    $top?: string;
    $skip?: string;
    $orderBy?: string;
    count?: boolean;
    countOnly?: boolean;
    avalaraVersion?: GetUserTenantsAvalaraVersionEnum;
    xCorrelationId?: string;
}

export interface ListUsersRequest {
    $filter?: string;
    $top?: string;
    $skip?: string;
    $orderBy?: string;
    count?: boolean;
    countOnly?: boolean;
    avalaraVersion?: ListUsersAvalaraVersionEnum;
    xCorrelationId?: string;
}

export interface PatchUserRequest {
    userId: string;
    avalaraVersion?: PatchUserAvalaraVersionEnum;
    xCorrelationId?: string;
    ifMatch?: string;
    user?: User;
}

export interface ReplaceUserRequest {
    userId: string;
    avalaraVersion?: ReplaceUserAvalaraVersionEnum;
    xCorrelationId?: string;
    ifMatch?: string;
    user?: User;
}

/**
 * 
 */
export class UserApi extends runtime.ApiClient {
    public sdkVersion: string = '2.4.41';

    constructor(apiClient: runtime.ApiClient) {
        super(apiClient.configuration);
    }

    /**
     * The response contains the same object as posted and fills in the newly assigned user ID.
     * Create a user.
     */
    async createUserRaw(requestParameters: CreateUserRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<User>> {
        const queryParameters: any = {};
        const requiredScopes = "TestScope1";
        const authNames: string[] = ['OAuth'];
        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.avalaraVersion !== undefined && requestParameters.avalaraVersion !== null) {
            headerParameters['avalara-version'] = String(requestParameters.avalaraVersion);
        }

        if (requestParameters.xCorrelationId !== undefined && requestParameters.xCorrelationId !== null) {
            headerParameters['X-Correlation-Id'] = String(requestParameters.xCorrelationId);
        }

        await this.applyAuthToRequest(headerParameters, authNames, requiredScopes);
        const response = await this.request({
            path: `/users`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UserToJSON(requestParameters.user),
        }, initOverrides, requiredScopes);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
    }

    /**
     * The response contains the same object as posted and fills in the newly assigned user ID.
     * Create a user.
     */
    async createUser(requestParameters: CreateUserRequest = {}, initOverrides?: RequestInit): Promise<User> {
        const response = await this.createUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes the specified user.
     * Delete a user.
     */
    async deleteUserRaw(requestParameters: DeleteUserRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling deleteUser.');
        }

        const queryParameters: any = {};
        const requiredScopes = "iam TestScope TestScope1";
        const authNames: string[] = ['OAuth'];
        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.avalaraVersion !== undefined && requestParameters.avalaraVersion !== null) {
            headerParameters['avalara-version'] = String(requestParameters.avalaraVersion);
        }

        if (requestParameters.xCorrelationId !== undefined && requestParameters.xCorrelationId !== null) {
            headerParameters['X-Correlation-Id'] = String(requestParameters.xCorrelationId);
        }

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }

        await this.applyAuthToRequest(headerParameters, authNames, requiredScopes);
        const response = await this.request({
            path: `/users/{user-id}`.replace(`{${"user-id"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides, requiredScopes);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes the specified user.
     * Delete a user.
     */
    async deleteUser(requestParameters: DeleteUserRequest, initOverrides?: RequestInit): Promise<void> {
        await this.deleteUserRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieves a specific user which the current ID has access to.
     * Retrieve a user.
     */
    async getUserRaw(requestParameters: GetUserRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<User>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling getUser.');
        }

        const queryParameters: any = {};
        const requiredScopes = "iam";
        const authNames: string[] = ['OAuth'];
        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.avalaraVersion !== undefined && requestParameters.avalaraVersion !== null) {
            headerParameters['avalara-version'] = String(requestParameters.avalaraVersion);
        }

        if (requestParameters.xCorrelationId !== undefined && requestParameters.xCorrelationId !== null) {
            headerParameters['X-Correlation-Id'] = String(requestParameters.xCorrelationId);
        }

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters['If-None-Match'] = String(requestParameters.ifNoneMatch);
        }

        await this.applyAuthToRequest(headerParameters, authNames, requiredScopes);
        const response = await this.request({
            path: `/users/{user-id}`.replace(`{${"user-id"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides, requiredScopes);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
    }

    /**
     * Retrieves a specific user which the current ID has access to.
     * Retrieve a user.
     */
    async getUser(requestParameters: GetUserRequest, initOverrides?: RequestInit): Promise<User> {
        const response = await this.getUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a list of acconts that the user is associated with.  Filterable properties:   * displayName * organization/identifier
     * Your GET endpoint
     */
    async getUserTenantsRaw(requestParameters: GetUserTenantsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<TenantList>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling getUserTenants.');
        }

        const queryParameters: any = {};
        const requiredScopes = "iam TestScope TestScope1";
        const authNames: string[] = ['OAuth'];
        if (requestParameters.$filter !== undefined) {
            queryParameters['$filter'] = requestParameters.$filter;
        }

        if (requestParameters.$top !== undefined) {
            queryParameters['$top'] = requestParameters.$top;
        }

        if (requestParameters.$skip !== undefined) {
            queryParameters['$skip'] = requestParameters.$skip;
        }

        if (requestParameters.$orderBy !== undefined) {
            queryParameters['$orderBy'] = requestParameters.$orderBy;
        }

        if (requestParameters.count !== undefined) {
            queryParameters['count'] = requestParameters.count;
        }

        if (requestParameters.countOnly !== undefined) {
            queryParameters['countOnly'] = requestParameters.countOnly;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.avalaraVersion !== undefined && requestParameters.avalaraVersion !== null) {
            headerParameters['avalara-version'] = String(requestParameters.avalaraVersion);
        }

        if (requestParameters.xCorrelationId !== undefined && requestParameters.xCorrelationId !== null) {
            headerParameters['X-Correlation-Id'] = String(requestParameters.xCorrelationId);
        }

        await this.applyAuthToRequest(headerParameters, authNames, requiredScopes);
        const response = await this.request({
            path: `/users/{user-id}/tenants`.replace(`{${"user-id"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides, requiredScopes);

        return new runtime.JSONApiResponse(response, (jsonValue) => TenantListFromJSON(jsonValue));
    }

    /**
     * Retrieve a list of acconts that the user is associated with.  Filterable properties:   * displayName * organization/identifier
     * Your GET endpoint
     */
    async getUserTenants(requestParameters: GetUserTenantsRequest, initOverrides?: RequestInit): Promise<TenantList> {
        const response = await this.getUserTenantsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a list of all users the authenticated user has access to. This list is paged, returning no more than 1000 items at a time.  Filterable properties:   * displayName * emails/value * active * userName
     * List all users which the current user has access to.
     */
    async listUsersRaw(requestParameters: ListUsersRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<UserList>> {
        const queryParameters: any = {};
        const requiredScopes = "TestScope TestScope1";
        const authNames: string[] = ['OAuth'];
        if (requestParameters.$filter !== undefined) {
            queryParameters['$filter'] = requestParameters.$filter;
        }

        if (requestParameters.$top !== undefined) {
            queryParameters['$top'] = requestParameters.$top;
        }

        if (requestParameters.$skip !== undefined) {
            queryParameters['$skip'] = requestParameters.$skip;
        }

        if (requestParameters.$orderBy !== undefined) {
            queryParameters['$orderBy'] = requestParameters.$orderBy;
        }

        if (requestParameters.count !== undefined) {
            queryParameters['count'] = requestParameters.count;
        }

        if (requestParameters.countOnly !== undefined) {
            queryParameters['countOnly'] = requestParameters.countOnly;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.avalaraVersion !== undefined && requestParameters.avalaraVersion !== null) {
            headerParameters['avalara-version'] = String(requestParameters.avalaraVersion);
        }

        if (requestParameters.xCorrelationId !== undefined && requestParameters.xCorrelationId !== null) {
            headerParameters['X-Correlation-Id'] = String(requestParameters.xCorrelationId);
        }

        await this.applyAuthToRequest(headerParameters, authNames, requiredScopes);
        const response = await this.request({
            path: `/users`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides, requiredScopes);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserListFromJSON(jsonValue));
    }

    /**
     * Retrieve a list of all users the authenticated user has access to. This list is paged, returning no more than 1000 items at a time.  Filterable properties:   * displayName * emails/value * active * userName
     * List all users which the current user has access to.
     */
    async listUsers(requestParameters: ListUsersRequest = {}, initOverrides?: RequestInit): Promise<UserList> {
        const response = await this.listUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates a user, only applying the changes delivered in the payload. 
     * Update the fields within the message body on the user.
     */
    async patchUserRaw(requestParameters: PatchUserRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling patchUser.');
        }

        const queryParameters: any = {};
        const requiredScopes = "iam TestScope TestScope1";
        const authNames: string[] = ['OAuth'];
        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.avalaraVersion !== undefined && requestParameters.avalaraVersion !== null) {
            headerParameters['avalara-version'] = String(requestParameters.avalaraVersion);
        }

        if (requestParameters.xCorrelationId !== undefined && requestParameters.xCorrelationId !== null) {
            headerParameters['X-Correlation-Id'] = String(requestParameters.xCorrelationId);
        }

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }

        await this.applyAuthToRequest(headerParameters, authNames, requiredScopes);
        const response = await this.request({
            path: `/users/{user-id}`.replace(`{${"user-id"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UserToJSON(requestParameters.user),
        }, initOverrides, requiredScopes);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates a user, only applying the changes delivered in the payload. 
     * Update the fields within the message body on the user.
     */
    async patchUser(requestParameters: PatchUserRequest, initOverrides?: RequestInit): Promise<void> {
        await this.patchUserRaw(requestParameters, initOverrides);
    }

    /**
     * Replaces the specified user with the user in the body.
     * Update all fields on a user.
     */
    async replaceUserRaw(requestParameters: ReplaceUserRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling replaceUser.');
        }

        const queryParameters: any = {};
        const requiredScopes = "TestScope TestScope1 iam";
        const authNames: string[] = ['OAuth'];
        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.avalaraVersion !== undefined && requestParameters.avalaraVersion !== null) {
            headerParameters['avalara-version'] = String(requestParameters.avalaraVersion);
        }

        if (requestParameters.xCorrelationId !== undefined && requestParameters.xCorrelationId !== null) {
            headerParameters['X-Correlation-Id'] = String(requestParameters.xCorrelationId);
        }

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }

        await this.applyAuthToRequest(headerParameters, authNames, requiredScopes);
        const response = await this.request({
            path: `/users/{user-id}`.replace(`{${"user-id"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UserToJSON(requestParameters.user),
        }, initOverrides, requiredScopes);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Replaces the specified user with the user in the body.
     * Update all fields on a user.
     */
    async replaceUser(requestParameters: ReplaceUserRequest, initOverrides?: RequestInit): Promise<void> {
        await this.replaceUserRaw(requestParameters, initOverrides);
    }

}

/**
    * @export
    * @enum {string}
    */
export enum CreateUserAvalaraVersionEnum {
    _100 = '1.0.0'
}
/**
    * @export
    * @enum {string}
    */
export enum DeleteUserAvalaraVersionEnum {
    _100 = '1.0.0'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUserAvalaraVersionEnum {
    _100 = '1.0.0'
}
/**
    * @export
    * @enum {string}
    */
export enum GetUserTenantsAvalaraVersionEnum {
    _100 = '1.0.0'
}
/**
    * @export
    * @enum {string}
    */
export enum ListUsersAvalaraVersionEnum {
    _100 = '1.0.0'
}
/**
    * @export
    * @enum {string}
    */
export enum PatchUserAvalaraVersionEnum {
    _100 = '1.0.0'
}
/**
    * @export
    * @enum {string}
    */
export enum ReplaceUserAvalaraVersionEnum {
    _100 = '1.0.0'
}
