/* tslint:disable */
/* eslint-disable */
/**
 * foundation
 * Platform foundation consists of services on top of which the Avalara Compliance Cloud platform is built. These services are foundational and provide functionality such as common organization, tenant and user management for the rest of the compliance platform.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../../runtime';
import { RequestInit } from 'node-fetch';
import {
    App,
    AppFromJSON,
    AppToJSON,
    AppList,
    AppListFromJSON,
    AppListToJSON,
    VersionError,
    VersionErrorFromJSON,
    VersionErrorToJSON,
} from '../../packages/IAMDS';

export interface AddGrantToAppRequest {
    appId: string;
    grantId: string;
    avalaraVersion?: AddGrantToAppAvalaraVersionEnum;
    xCorrelationId?: string;
}

export interface CreateAppRequest {
    avalaraVersion?: CreateAppAvalaraVersionEnum;
    xCorrelationId?: string;
    app?: App;
}

export interface CreateAppSecretRequest {
    appId: string;
    avalaraVersion?: CreateAppSecretAvalaraVersionEnum;
    xCorrelationId?: string;
}

export interface DeleteAppRequest {
    appId: string;
    avalaraVersion?: DeleteAppAvalaraVersionEnum;
    xCorrelationId?: string;
    ifMatch?: string;
}

export interface GetAppRequest {
    appId: string;
    avalaraVersion?: GetAppAvalaraVersionEnum;
    xCorrelationId?: string;
    ifNoneMatch?: string;
}

export interface ListAppGrantsRequest {
    appId: string;
    $filter?: string;
    $top?: string;
    $skip?: string;
    $orderBy?: string;
    count?: boolean;
    countOnly?: boolean;
    avalaraVersion?: ListAppGrantsAvalaraVersionEnum;
    xCorrelationId?: string;
}

export interface ListAppsRequest {
    $filter?: string;
    $top?: string;
    $skip?: string;
    $orderBy?: string;
    count?: boolean;
    countOnly?: boolean;
    avalaraVersion?: ListAppsAvalaraVersionEnum;
    xCorrelationId?: string;
}

export interface PatchAppRequest {
    appId: string;
    avalaraVersion?: PatchAppAvalaraVersionEnum;
    xCorrelationId?: string;
    ifMatch?: string;
    app?: App;
}

export interface RemoveGrantFromAppRequest {
    appId: string;
    grantId: string;
    avalaraVersion?: RemoveGrantFromAppAvalaraVersionEnum;
    xCorrelationId?: string;
}

export interface ReplaceAppRequest {
    appId: string;
    avalaraVersion?: ReplaceAppAvalaraVersionEnum;
    xCorrelationId?: string;
    ifMatch?: string;
    app?: App;
}

/**
 * 
 */
export class AppApi extends runtime.ApiClient {
    public sdkVersion: string = '2.4.41';

    constructor(apiClient: runtime.ApiClient) {
        super(apiClient.configuration);
    }

    /**
     * Adds a grant to an app.
     * Add a grant to an app.
     */
    async addGrantToAppRaw(requestParameters: AddGrantToAppRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.appId === null || requestParameters.appId === undefined) {
            throw new runtime.RequiredError('appId','Required parameter requestParameters.appId was null or undefined when calling addGrantToApp.');
        }

        if (requestParameters.grantId === null || requestParameters.grantId === undefined) {
            throw new runtime.RequiredError('grantId','Required parameter requestParameters.grantId was null or undefined when calling addGrantToApp.');
        }

        const queryParameters: any = {};
        const requiredScopes = "iam TestScope TestScope1";
        const authNames: string[] = ['OAuth'];
        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.avalaraVersion !== undefined && requestParameters.avalaraVersion !== null) {
            headerParameters['avalara-version'] = String(requestParameters.avalaraVersion);
        }

        if (requestParameters.xCorrelationId !== undefined && requestParameters.xCorrelationId !== null) {
            headerParameters['X-Correlation-Id'] = String(requestParameters.xCorrelationId);
        }

        await this.applyAuthToRequest(headerParameters, authNames, requiredScopes);
        const response = await this.request({
            path: `/apps/{app-id}/grants/{grant-id}`.replace(`{${"app-id"}}`, encodeURIComponent(String(requestParameters.appId))).replace(`{${"grant-id"}}`, encodeURIComponent(String(requestParameters.grantId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Adds a grant to an app.
     * Add a grant to an app.
     */
    async addGrantToApp(requestParameters: AddGrantToAppRequest, initOverrides?: RequestInit): Promise<void> {
        await this.addGrantToAppRaw(requestParameters, initOverrides);
    }

    /**
     * The response contains the same object as posted and fills in the newly assigned app ID.
     * Add an app.
     */
    async createAppRaw(requestParameters: CreateAppRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<App>> {
        const queryParameters: any = {};
        const requiredScopes = "iam TestScope TestScope1";
        const authNames: string[] = ['OAuth'];
        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.avalaraVersion !== undefined && requestParameters.avalaraVersion !== null) {
            headerParameters['avalara-version'] = String(requestParameters.avalaraVersion);
        }

        if (requestParameters.xCorrelationId !== undefined && requestParameters.xCorrelationId !== null) {
            headerParameters['X-Correlation-Id'] = String(requestParameters.xCorrelationId);
        }

        await this.applyAuthToRequest(headerParameters, authNames, requiredScopes);
        const response = await this.request({
            path: `/apps`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AppToJSON(requestParameters.app),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AppFromJSON(jsonValue));
    }

    /**
     * The response contains the same object as posted and fills in the newly assigned app ID.
     * Add an app.
     */
    async createApp(requestParameters: CreateAppRequest = {}, initOverrides?: RequestInit): Promise<App> {
        const response = await this.createAppRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates or recreates the secret for an app. The new value is returned as a string. 
     * Create a new secret for the app.
     */
    async createAppSecretRaw(requestParameters: CreateAppSecretRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.appId === null || requestParameters.appId === undefined) {
            throw new runtime.RequiredError('appId','Required parameter requestParameters.appId was null or undefined when calling createAppSecret.');
        }

        const queryParameters: any = {};
        const requiredScopes = "iam TestScope TestScope1";
        const authNames: string[] = ['OAuth'];
        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.avalaraVersion !== undefined && requestParameters.avalaraVersion !== null) {
            headerParameters['avalara-version'] = String(requestParameters.avalaraVersion);
        }

        if (requestParameters.xCorrelationId !== undefined && requestParameters.xCorrelationId !== null) {
            headerParameters['X-Correlation-Id'] = String(requestParameters.xCorrelationId);
        }

        await this.applyAuthToRequest(headerParameters, authNames, requiredScopes);
        const response = await this.request({
            path: `/apps/{app-id}/secret`.replace(`{${"app-id"}}`, encodeURIComponent(String(requestParameters.appId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Creates or recreates the secret for an app. The new value is returned as a string. 
     * Create a new secret for the app.
     */
    async createAppSecret(requestParameters: CreateAppSecretRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.createAppSecretRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes the specified app.
     * Delete an app by ID.
     */
    async deleteAppRaw(requestParameters: DeleteAppRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.appId === null || requestParameters.appId === undefined) {
            throw new runtime.RequiredError('appId','Required parameter requestParameters.appId was null or undefined when calling deleteApp.');
        }

        const queryParameters: any = {};
        const requiredScopes = "iam TestScope TestScope1";
        const authNames: string[] = ['OAuth'];
        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.avalaraVersion !== undefined && requestParameters.avalaraVersion !== null) {
            headerParameters['avalara-version'] = String(requestParameters.avalaraVersion);
        }

        if (requestParameters.xCorrelationId !== undefined && requestParameters.xCorrelationId !== null) {
            headerParameters['X-Correlation-Id'] = String(requestParameters.xCorrelationId);
        }

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }

        await this.applyAuthToRequest(headerParameters, authNames, requiredScopes);
        const response = await this.request({
            path: `/apps/{app-id}`.replace(`{${"app-id"}}`, encodeURIComponent(String(requestParameters.appId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes the specified app.
     * Delete an app by ID.
     */
    async deleteApp(requestParameters: DeleteAppRequest, initOverrides?: RequestInit): Promise<void> {
        await this.deleteAppRaw(requestParameters, initOverrides);
    }

    /**
     * Retrives an app by its ID.
     * Get an app by ID.
     */
    async getAppRaw(requestParameters: GetAppRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<App>> {
        if (requestParameters.appId === null || requestParameters.appId === undefined) {
            throw new runtime.RequiredError('appId','Required parameter requestParameters.appId was null or undefined when calling getApp.');
        }

        const queryParameters: any = {};
        const requiredScopes = "iam TestScope TestScope1";
        const authNames: string[] = ['OAuth'];
        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.avalaraVersion !== undefined && requestParameters.avalaraVersion !== null) {
            headerParameters['avalara-version'] = String(requestParameters.avalaraVersion);
        }

        if (requestParameters.xCorrelationId !== undefined && requestParameters.xCorrelationId !== null) {
            headerParameters['X-Correlation-Id'] = String(requestParameters.xCorrelationId);
        }

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters['If-None-Match'] = String(requestParameters.ifNoneMatch);
        }

        await this.applyAuthToRequest(headerParameters, authNames, requiredScopes);
        const response = await this.request({
            path: `/apps/{app-id}`.replace(`{${"app-id"}}`, encodeURIComponent(String(requestParameters.appId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AppFromJSON(jsonValue));
    }

    /**
     * Retrives an app by its ID.
     * Get an app by ID.
     */
    async getApp(requestParameters: GetAppRequest, initOverrides?: RequestInit): Promise<App> {
        const response = await this.getAppRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a list of all grants an app belongs to which the authenticated user has access to. This list is paged, returning no more than 1000 items at a time.  Filterable properties:   * displayName * system/identifier * type * role/identifier
     * List all grants for a given app.
     */
    async listAppGrantsRaw(requestParameters: ListAppGrantsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<AppList>> {
        if (requestParameters.appId === null || requestParameters.appId === undefined) {
            throw new runtime.RequiredError('appId','Required parameter requestParameters.appId was null or undefined when calling listAppGrants.');
        }

        const queryParameters: any = {};
        const requiredScopes = "iam TestScope TestScope1";
        const authNames: string[] = ['OAuth'];
        if (requestParameters.$filter !== undefined) {
            queryParameters['$filter'] = requestParameters.$filter;
        }

        if (requestParameters.$top !== undefined) {
            queryParameters['$top'] = requestParameters.$top;
        }

        if (requestParameters.$skip !== undefined) {
            queryParameters['$skip'] = requestParameters.$skip;
        }

        if (requestParameters.$orderBy !== undefined) {
            queryParameters['$orderBy'] = requestParameters.$orderBy;
        }

        if (requestParameters.count !== undefined) {
            queryParameters['count'] = requestParameters.count;
        }

        if (requestParameters.countOnly !== undefined) {
            queryParameters['countOnly'] = requestParameters.countOnly;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.avalaraVersion !== undefined && requestParameters.avalaraVersion !== null) {
            headerParameters['avalara-version'] = String(requestParameters.avalaraVersion);
        }

        if (requestParameters.xCorrelationId !== undefined && requestParameters.xCorrelationId !== null) {
            headerParameters['X-Correlation-Id'] = String(requestParameters.xCorrelationId);
        }

        await this.applyAuthToRequest(headerParameters, authNames, requiredScopes);
        const response = await this.request({
            path: `/apps/{app-id}/grants`.replace(`{${"app-id"}}`, encodeURIComponent(String(requestParameters.appId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AppListFromJSON(jsonValue));
    }

    /**
     * Retrieve a list of all grants an app belongs to which the authenticated user has access to. This list is paged, returning no more than 1000 items at a time.  Filterable properties:   * displayName * system/identifier * type * role/identifier
     * List all grants for a given app.
     */
    async listAppGrants(requestParameters: ListAppGrantsRequest, initOverrides?: RequestInit): Promise<AppList> {
        const response = await this.listAppGrantsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a list of all apps the authenticated user has access to. This list is paged, returning no more than 1000 items at a time.  Filterable properties:   * displayName * type * organization/identifier * tenants/identifier * grants/identifier 
     * List apps which the user has access to.
     */
    async listAppsRaw(requestParameters: ListAppsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<AppList>> {
        const queryParameters: any = {};
        const requiredScopes = "iam TestScope TestScope1";
        const authNames: string[] = ['OAuth'];
        if (requestParameters.$filter !== undefined) {
            queryParameters['$filter'] = requestParameters.$filter;
        }

        if (requestParameters.$top !== undefined) {
            queryParameters['$top'] = requestParameters.$top;
        }

        if (requestParameters.$skip !== undefined) {
            queryParameters['$skip'] = requestParameters.$skip;
        }

        if (requestParameters.$orderBy !== undefined) {
            queryParameters['$orderBy'] = requestParameters.$orderBy;
        }

        if (requestParameters.count !== undefined) {
            queryParameters['count'] = requestParameters.count;
        }

        if (requestParameters.countOnly !== undefined) {
            queryParameters['countOnly'] = requestParameters.countOnly;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.avalaraVersion !== undefined && requestParameters.avalaraVersion !== null) {
            headerParameters['avalara-version'] = String(requestParameters.avalaraVersion);
        }

        if (requestParameters.xCorrelationId !== undefined && requestParameters.xCorrelationId !== null) {
            headerParameters['X-Correlation-Id'] = String(requestParameters.xCorrelationId);
        }

        await this.applyAuthToRequest(headerParameters, authNames, requiredScopes);
        const response = await this.request({
            path: `/apps`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AppListFromJSON(jsonValue));
    }

    /**
     * Retrieve a list of all apps the authenticated user has access to. This list is paged, returning no more than 1000 items at a time.  Filterable properties:   * displayName * type * organization/identifier * tenants/identifier * grants/identifier 
     * List apps which the user has access to.
     */
    async listApps(requestParameters: ListAppsRequest = {}, initOverrides?: RequestInit): Promise<AppList> {
        const response = await this.listAppsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates a set of fields on the app.
     * Update only fields in the body for the app.
     */
    async patchAppRaw(requestParameters: PatchAppRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.appId === null || requestParameters.appId === undefined) {
            throw new runtime.RequiredError('appId','Required parameter requestParameters.appId was null or undefined when calling patchApp.');
        }

        const queryParameters: any = {};
        const requiredScopes = "iam TestScope TestScope1";
        const authNames: string[] = ['OAuth'];
        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.avalaraVersion !== undefined && requestParameters.avalaraVersion !== null) {
            headerParameters['avalara-version'] = String(requestParameters.avalaraVersion);
        }

        if (requestParameters.xCorrelationId !== undefined && requestParameters.xCorrelationId !== null) {
            headerParameters['X-Correlation-Id'] = String(requestParameters.xCorrelationId);
        }

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }

        await this.applyAuthToRequest(headerParameters, authNames, requiredScopes);
        const response = await this.request({
            path: `/apps/{app-id}`.replace(`{${"app-id"}}`, encodeURIComponent(String(requestParameters.appId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: AppToJSON(requestParameters.app),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates a set of fields on the app.
     * Update only fields in the body for the app.
     */
    async patchApp(requestParameters: PatchAppRequest, initOverrides?: RequestInit): Promise<void> {
        await this.patchAppRaw(requestParameters, initOverrides);
    }

    /**
     * Removes a grant from an app.
     * Remove a grant from an app.
     */
    async removeGrantFromAppRaw(requestParameters: RemoveGrantFromAppRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.appId === null || requestParameters.appId === undefined) {
            throw new runtime.RequiredError('appId','Required parameter requestParameters.appId was null or undefined when calling removeGrantFromApp.');
        }

        if (requestParameters.grantId === null || requestParameters.grantId === undefined) {
            throw new runtime.RequiredError('grantId','Required parameter requestParameters.grantId was null or undefined when calling removeGrantFromApp.');
        }

        const queryParameters: any = {};
        const requiredScopes = "iam TestScope TestScope1";
        const authNames: string[] = ['OAuth'];
        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.avalaraVersion !== undefined && requestParameters.avalaraVersion !== null) {
            headerParameters['avalara-version'] = String(requestParameters.avalaraVersion);
        }

        if (requestParameters.xCorrelationId !== undefined && requestParameters.xCorrelationId !== null) {
            headerParameters['X-Correlation-Id'] = String(requestParameters.xCorrelationId);
        }

        await this.applyAuthToRequest(headerParameters, authNames, requiredScopes);
        const response = await this.request({
            path: `/apps/{app-id}/grants/{grant-id}`.replace(`{${"app-id"}}`, encodeURIComponent(String(requestParameters.appId))).replace(`{${"grant-id"}}`, encodeURIComponent(String(requestParameters.grantId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Removes a grant from an app.
     * Remove a grant from an app.
     */
    async removeGrantFromApp(requestParameters: RemoveGrantFromAppRequest, initOverrides?: RequestInit): Promise<void> {
        await this.removeGrantFromAppRaw(requestParameters, initOverrides);
    }

    /**
     * Replaces the specified app with the app in the body. 
     * Update all fields in an app by ID.
     */
    async replaceAppRaw(requestParameters: ReplaceAppRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.appId === null || requestParameters.appId === undefined) {
            throw new runtime.RequiredError('appId','Required parameter requestParameters.appId was null or undefined when calling replaceApp.');
        }

        const queryParameters: any = {};
        const requiredScopes = "iam TestScope TestScope1";
        const authNames: string[] = ['OAuth'];
        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.avalaraVersion !== undefined && requestParameters.avalaraVersion !== null) {
            headerParameters['avalara-version'] = String(requestParameters.avalaraVersion);
        }

        if (requestParameters.xCorrelationId !== undefined && requestParameters.xCorrelationId !== null) {
            headerParameters['X-Correlation-Id'] = String(requestParameters.xCorrelationId);
        }

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }

        await this.applyAuthToRequest(headerParameters, authNames, requiredScopes);
        const response = await this.request({
            path: `/apps/{app-id}`.replace(`{${"app-id"}}`, encodeURIComponent(String(requestParameters.appId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AppToJSON(requestParameters.app),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Replaces the specified app with the app in the body. 
     * Update all fields in an app by ID.
     */
    async replaceApp(requestParameters: ReplaceAppRequest, initOverrides?: RequestInit): Promise<void> {
        await this.replaceAppRaw(requestParameters, initOverrides);
    }

}

/**
    * @export
    * @enum {string}
    */
export enum AddGrantToAppAvalaraVersionEnum {
    _100 = '1.0.0'
}
/**
    * @export
    * @enum {string}
    */
export enum CreateAppAvalaraVersionEnum {
    _100 = '1.0.0'
}
/**
    * @export
    * @enum {string}
    */
export enum CreateAppSecretAvalaraVersionEnum {
    _100 = '1.0.0'
}
/**
    * @export
    * @enum {string}
    */
export enum DeleteAppAvalaraVersionEnum {
    _100 = '1.0.0'
}
/**
    * @export
    * @enum {string}
    */
export enum GetAppAvalaraVersionEnum {
    _100 = '1.0.0'
}
/**
    * @export
    * @enum {string}
    */
export enum ListAppGrantsAvalaraVersionEnum {
    _100 = '1.0.0'
}
/**
    * @export
    * @enum {string}
    */
export enum ListAppsAvalaraVersionEnum {
    _100 = '1.0.0'
}
/**
    * @export
    * @enum {string}
    */
export enum PatchAppAvalaraVersionEnum {
    _100 = '1.0.0'
}
/**
    * @export
    * @enum {string}
    */
export enum RemoveGrantFromAppAvalaraVersionEnum {
    _100 = '1.0.0'
}
/**
    * @export
    * @enum {string}
    */
export enum ReplaceAppAvalaraVersionEnum {
    _100 = '1.0.0'
}
