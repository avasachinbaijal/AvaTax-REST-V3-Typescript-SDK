/* tslint:disable */
/* eslint-disable */
/**
 * foundation
 * Platform foundation consists of services on top of which the Avalara Compliance Cloud platform is built. These services are foundational and provide functionality such as common organization, tenant and user management for the rest of the compliance platform.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../../runtime';
import { RequestInit } from 'node-fetch';
import {
    Feature,
    FeatureFromJSON,
    FeatureToJSON,
    FeatureList,
    FeatureListFromJSON,
    FeatureListToJSON,
    GrantList,
    GrantListFromJSON,
    GrantListToJSON,
    VersionError,
    VersionErrorFromJSON,
    VersionErrorToJSON,
} from '../../packages/IAMDS';

export interface CreateFeatureRequest {
    avalaraVersion?: CreateFeatureAvalaraVersionEnum;
    xCorrelationId?: string;
    feature?: Feature;
}

export interface DeleteFeatureRequest {
    featureId: string;
    avalaraVersion?: DeleteFeatureAvalaraVersionEnum;
    xCorrelationId?: string;
    ifMatch?: string;
}

export interface GetFeatureRequest {
    featureId: string;
    avalaraVersion?: GetFeatureAvalaraVersionEnum;
    xCorrelationId?: string;
    ifNoneMatch?: string;
}

export interface ListFeatureGrantsRequest {
    featureId: string;
    $filter?: string;
    $top?: string;
    $skip?: string;
    $orderBy?: string;
    count?: boolean;
    countOnly?: boolean;
    avalaraVersion?: ListFeatureGrantsAvalaraVersionEnum;
    xCorrelationId?: string;
}

export interface ListFeaturesRequest {
    $filter?: string;
    $top?: string;
    $skip?: string;
    $orderBy?: string;
    count?: boolean;
    countOnly?: boolean;
    avalaraVersion?: ListFeaturesAvalaraVersionEnum;
    xCorrelationId?: string;
}

export interface PatchFeatureRequest {
    featureId: string;
    avalaraVersion?: PatchFeatureAvalaraVersionEnum;
    xCorrelationId?: string;
    ifMatch?: string;
    feature?: Feature;
}

export interface ReplaceFeatureRequest {
    featureId: string;
    avalaraVersion?: ReplaceFeatureAvalaraVersionEnum;
    xCorrelationId?: string;
    ifMatch?: string;
    feature?: Feature;
}

/**
 * 
 */
export class FeatureApi extends runtime.ApiClient {
    public sdkVersion: string = '2.4.41';

    constructor(apiClient: runtime.ApiClient) {
        super(apiClient.configuration);
    }

    /**
     * The response contains the same object as posted and fills in the newly assigned feature ID.
     * Create a feature.
     */
    async createFeatureRaw(requestParameters: CreateFeatureRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Feature>> {
        const queryParameters: any = {};
        const requiredScopes = "iam TestScope TestScope1";
        const authNames: string[] = ['OAuth'];
        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.avalaraVersion !== undefined && requestParameters.avalaraVersion !== null) {
            headerParameters['avalara-version'] = String(requestParameters.avalaraVersion);
        }

        if (requestParameters.xCorrelationId !== undefined && requestParameters.xCorrelationId !== null) {
            headerParameters['X-Correlation-Id'] = String(requestParameters.xCorrelationId);
        }

        await this.applyAuthToRequest(headerParameters, authNames, requiredScopes);
        const response = await this.request({
            path: `/features`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FeatureToJSON(requestParameters.feature),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FeatureFromJSON(jsonValue));
    }

    /**
     * The response contains the same object as posted and fills in the newly assigned feature ID.
     * Create a feature.
     */
    async createFeature(requestParameters: CreateFeatureRequest = {}, initOverrides?: RequestInit): Promise<Feature> {
        const response = await this.createFeatureRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes the feature by ID.
     * Delete a feature.
     */
    async deleteFeatureRaw(requestParameters: DeleteFeatureRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.featureId === null || requestParameters.featureId === undefined) {
            throw new runtime.RequiredError('featureId','Required parameter requestParameters.featureId was null or undefined when calling deleteFeature.');
        }

        const queryParameters: any = {};
        const requiredScopes = "iam TestScope TestScope1";
        const authNames: string[] = ['OAuth'];
        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.avalaraVersion !== undefined && requestParameters.avalaraVersion !== null) {
            headerParameters['avalara-version'] = String(requestParameters.avalaraVersion);
        }

        if (requestParameters.xCorrelationId !== undefined && requestParameters.xCorrelationId !== null) {
            headerParameters['X-Correlation-Id'] = String(requestParameters.xCorrelationId);
        }

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }

        await this.applyAuthToRequest(headerParameters, authNames, requiredScopes);
        const response = await this.request({
            path: `/features/{feature-id}`.replace(`{${"feature-id"}}`, encodeURIComponent(String(requestParameters.featureId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes the feature by ID.
     * Delete a feature.
     */
    async deleteFeature(requestParameters: DeleteFeatureRequest, initOverrides?: RequestInit): Promise<void> {
        await this.deleteFeatureRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieves the specified feature.
     * Get a feature.
     */
    async getFeatureRaw(requestParameters: GetFeatureRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Feature>> {
        if (requestParameters.featureId === null || requestParameters.featureId === undefined) {
            throw new runtime.RequiredError('featureId','Required parameter requestParameters.featureId was null or undefined when calling getFeature.');
        }

        const queryParameters: any = {};
        const requiredScopes = "iam TestScope TestScope1";
        const authNames: string[] = ['OAuth'];
        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.avalaraVersion !== undefined && requestParameters.avalaraVersion !== null) {
            headerParameters['avalara-version'] = String(requestParameters.avalaraVersion);
        }

        if (requestParameters.xCorrelationId !== undefined && requestParameters.xCorrelationId !== null) {
            headerParameters['X-Correlation-Id'] = String(requestParameters.xCorrelationId);
        }

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters['If-None-Match'] = String(requestParameters.ifNoneMatch);
        }

        await this.applyAuthToRequest(headerParameters, authNames, requiredScopes);
        const response = await this.request({
            path: `/features/{feature-id}`.replace(`{${"feature-id"}}`, encodeURIComponent(String(requestParameters.featureId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FeatureFromJSON(jsonValue));
    }

    /**
     * Retrieves the specified feature.
     * Get a feature.
     */
    async getFeature(requestParameters: GetFeatureRequest, initOverrides?: RequestInit): Promise<Feature> {
        const response = await this.getFeatureRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a list of all grants a feature belongs to which the authenticated user has access to. This list is paged, returning no more than 1000 items at a time.  Filterable properties:  * displayName * role/identifier
     * List all grants on a feature.
     */
    async listFeatureGrantsRaw(requestParameters: ListFeatureGrantsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<GrantList>> {
        if (requestParameters.featureId === null || requestParameters.featureId === undefined) {
            throw new runtime.RequiredError('featureId','Required parameter requestParameters.featureId was null or undefined when calling listFeatureGrants.');
        }

        const queryParameters: any = {};
        const requiredScopes = "iam TestScope TestScope1";
        const authNames: string[] = ['OAuth'];
        if (requestParameters.$filter !== undefined) {
            queryParameters['$filter'] = requestParameters.$filter;
        }

        if (requestParameters.$top !== undefined) {
            queryParameters['$top'] = requestParameters.$top;
        }

        if (requestParameters.$skip !== undefined) {
            queryParameters['$skip'] = requestParameters.$skip;
        }

        if (requestParameters.$orderBy !== undefined) {
            queryParameters['$orderBy'] = requestParameters.$orderBy;
        }

        if (requestParameters.count !== undefined) {
            queryParameters['count'] = requestParameters.count;
        }

        if (requestParameters.countOnly !== undefined) {
            queryParameters['countOnly'] = requestParameters.countOnly;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.avalaraVersion !== undefined && requestParameters.avalaraVersion !== null) {
            headerParameters['avalara-version'] = String(requestParameters.avalaraVersion);
        }

        if (requestParameters.xCorrelationId !== undefined && requestParameters.xCorrelationId !== null) {
            headerParameters['X-Correlation-Id'] = String(requestParameters.xCorrelationId);
        }

        await this.applyAuthToRequest(headerParameters, authNames, requiredScopes);
        const response = await this.request({
            path: `/features/{feature-id}/grants`.replace(`{${"feature-id"}}`, encodeURIComponent(String(requestParameters.featureId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GrantListFromJSON(jsonValue));
    }

    /**
     * Retrieve a list of all grants a feature belongs to which the authenticated user has access to. This list is paged, returning no more than 1000 items at a time.  Filterable properties:  * displayName * role/identifier
     * List all grants on a feature.
     */
    async listFeatureGrants(requestParameters: ListFeatureGrantsRequest, initOverrides?: RequestInit): Promise<GrantList> {
        const response = await this.listFeatureGrantsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a list of all features the authenticated user has access to. This list is paged, returning no more than 1000 items at a time.  Filterable properties:  * displayName * system/identifier * grants/identifier
     * Get all features which the user has access to.
     */
    async listFeaturesRaw(requestParameters: ListFeaturesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<FeatureList>> {
        const queryParameters: any = {};
        const requiredScopes = "iam TestScope TestScope1";
        const authNames: string[] = ['OAuth'];
        if (requestParameters.$filter !== undefined) {
            queryParameters['$filter'] = requestParameters.$filter;
        }

        if (requestParameters.$top !== undefined) {
            queryParameters['$top'] = requestParameters.$top;
        }

        if (requestParameters.$skip !== undefined) {
            queryParameters['$skip'] = requestParameters.$skip;
        }

        if (requestParameters.$orderBy !== undefined) {
            queryParameters['$orderBy'] = requestParameters.$orderBy;
        }

        if (requestParameters.count !== undefined) {
            queryParameters['count'] = requestParameters.count;
        }

        if (requestParameters.countOnly !== undefined) {
            queryParameters['countOnly'] = requestParameters.countOnly;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.avalaraVersion !== undefined && requestParameters.avalaraVersion !== null) {
            headerParameters['avalara-version'] = String(requestParameters.avalaraVersion);
        }

        if (requestParameters.xCorrelationId !== undefined && requestParameters.xCorrelationId !== null) {
            headerParameters['X-Correlation-Id'] = String(requestParameters.xCorrelationId);
        }

        await this.applyAuthToRequest(headerParameters, authNames, requiredScopes);
        const response = await this.request({
            path: `/features`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FeatureListFromJSON(jsonValue));
    }

    /**
     * Retrieve a list of all features the authenticated user has access to. This list is paged, returning no more than 1000 items at a time.  Filterable properties:  * displayName * system/identifier * grants/identifier
     * Get all features which the user has access to.
     */
    async listFeatures(requestParameters: ListFeaturesRequest = {}, initOverrides?: RequestInit): Promise<FeatureList> {
        const response = await this.listFeaturesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates only the fields passed in for the specified feature.
     * Update the fields within the body on the feature.
     */
    async patchFeatureRaw(requestParameters: PatchFeatureRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.featureId === null || requestParameters.featureId === undefined) {
            throw new runtime.RequiredError('featureId','Required parameter requestParameters.featureId was null or undefined when calling patchFeature.');
        }

        const queryParameters: any = {};
        const requiredScopes = "iam TestScope TestScope1";
        const authNames: string[] = ['OAuth'];
        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.avalaraVersion !== undefined && requestParameters.avalaraVersion !== null) {
            headerParameters['avalara-version'] = String(requestParameters.avalaraVersion);
        }

        if (requestParameters.xCorrelationId !== undefined && requestParameters.xCorrelationId !== null) {
            headerParameters['X-Correlation-Id'] = String(requestParameters.xCorrelationId);
        }

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }

        await this.applyAuthToRequest(headerParameters, authNames, requiredScopes);
        const response = await this.request({
            path: `/features/{feature-id}`.replace(`{${"feature-id"}}`, encodeURIComponent(String(requestParameters.featureId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: FeatureToJSON(requestParameters.feature),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates only the fields passed in for the specified feature.
     * Update the fields within the body on the feature.
     */
    async patchFeature(requestParameters: PatchFeatureRequest, initOverrides?: RequestInit): Promise<void> {
        await this.patchFeatureRaw(requestParameters, initOverrides);
    }

    /**
     * Replaces the specified feature with the feature in the body.
     * Update all fields on a feature.
     */
    async replaceFeatureRaw(requestParameters: ReplaceFeatureRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.featureId === null || requestParameters.featureId === undefined) {
            throw new runtime.RequiredError('featureId','Required parameter requestParameters.featureId was null or undefined when calling replaceFeature.');
        }

        const queryParameters: any = {};
        const requiredScopes = "iam TestScope TestScope1";
        const authNames: string[] = ['OAuth'];
        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.avalaraVersion !== undefined && requestParameters.avalaraVersion !== null) {
            headerParameters['avalara-version'] = String(requestParameters.avalaraVersion);
        }

        if (requestParameters.xCorrelationId !== undefined && requestParameters.xCorrelationId !== null) {
            headerParameters['X-Correlation-Id'] = String(requestParameters.xCorrelationId);
        }

        if (requestParameters.ifMatch !== undefined && requestParameters.ifMatch !== null) {
            headerParameters['If-Match'] = String(requestParameters.ifMatch);
        }

        await this.applyAuthToRequest(headerParameters, authNames, requiredScopes);
        const response = await this.request({
            path: `/features/{feature-id}`.replace(`{${"feature-id"}}`, encodeURIComponent(String(requestParameters.featureId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: FeatureToJSON(requestParameters.feature),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Replaces the specified feature with the feature in the body.
     * Update all fields on a feature.
     */
    async replaceFeature(requestParameters: ReplaceFeatureRequest, initOverrides?: RequestInit): Promise<void> {
        await this.replaceFeatureRaw(requestParameters, initOverrides);
    }

}

/**
    * @export
    * @enum {string}
    */
export enum CreateFeatureAvalaraVersionEnum {
    _100 = '1.0.0'
}
/**
    * @export
    * @enum {string}
    */
export enum DeleteFeatureAvalaraVersionEnum {
    _100 = '1.0.0'
}
/**
    * @export
    * @enum {string}
    */
export enum GetFeatureAvalaraVersionEnum {
    _100 = '1.0.0'
}
/**
    * @export
    * @enum {string}
    */
export enum ListFeatureGrantsAvalaraVersionEnum {
    _100 = '1.0.0'
}
/**
    * @export
    * @enum {string}
    */
export enum ListFeaturesAvalaraVersionEnum {
    _100 = '1.0.0'
}
/**
    * @export
    * @enum {string}
    */
export enum PatchFeatureAvalaraVersionEnum {
    _100 = '1.0.0'
}
/**
    * @export
    * @enum {string}
    */
export enum ReplaceFeatureAvalaraVersionEnum {
    _100 = '1.0.0'
}
