/* tslint:disable */
/* eslint-disable */
/**
 * foundation
 * Platform foundation consists of services on top of which the Avalara Compliance Cloud platform is built. These services are foundational and provide functionality such as common organization, tenant and user management for the rest of the compliance platform.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import fetch, { Response, RequestInfo, RequestInit } from 'node-fetch';
export const PRODUCTION_OPENID_CONFIG_URL = 'https://identity.avalara.com/.well-known/openid-configuration';
export const SANDBOX_OPENID_CONFIG_URL = 'https://ai-sbx.avlr.sh/.well-known/openid-configuration';
export const QA_OPENID_CONFIG_URL = 'https://ai-awscqa.avlr.sh/.well-known/openid-configuration';

const isBlob = (value: any) => (typeof Blob) !== 'undefined' && value instanceof Blob;

/**
 * This is the base class for all generated API classes.
 */
export class ApiClient {

    private middleware: Middleware[];
    public sdkVersion: string = null;
    private accessTokenMap: Map<string, TokenMetadata> = new Map();
    public tokenUrl = null;

    constructor(public configuration: Configuration) {
        if (!configuration) {
            throw new Error('Configuration object is a required parameter for ApiClient.');
        }
        this.middleware = configuration.middleware || [];
    }

    withMiddleware<T extends ApiClient>(this: T, ...middlewares: Middleware[]) {
        const next = this.clone<T>();
        next.middleware = next.middleware.concat(...middlewares);
        return next;
    }

    withPreMiddleware<T extends ApiClient>(this: T, ...preMiddlewares: Array<Middleware['pre']>) {
        const middlewares = preMiddlewares.map((pre) => ({ pre }));
        return this.withMiddleware<T>(...middlewares);
    }

    withPostMiddleware<T extends ApiClient>(this: T, ...postMiddlewares: Array<Middleware['post']>) {
        const middlewares = postMiddlewares.map((post) => ({ post }));
        return this.withMiddleware<T>(...middlewares);
    }

    protected async request(context: RequestOpts, initOverrides?: RequestInit, requiredScopes: string = '', isRetry: boolean = false): Promise<Response> {
        const { url, init, timeoutId } = this.createFetchParams(context, initOverrides);
        const { clientId, clientSecret } = this.configuration;
        const response = await this.fetchApi(url, init);
        const { status, headers } = response;
        clearTimeout(timeoutId);
        if (status >= 200 && status < 300) {
            return response;
        }
        // Retry logic for OAuth token failure, if we receive 401 or 403 back, try to fetch a new token and make the API call a second time. If that fails again, return error as normal to the caller.
        if ((status === 401 || status === 403) && clientId && clientSecret) {
            const authHeader = headers.Authorization;
            const authHeaderValues = authHeader && authHeader.split(' ');
            if (authHeaderValues && authHeaderValues.length === 2 && !isRetry) {
                await this.updateOAuthAccessToken(requiredScopes, authHeaderValues[1]);
                return this.request(context, initOverrides, requiredScopes, true);
            }
        }
        throw response;
    }

    protected async applyAuthToRequest(headerParameters: HTTPHeaders, authNames: string[], requiredScopes: string) {
        const { bearerToken, clientId, clientSecret, username, password } = this.configuration;
        // for now, only support basic and oauth types.
        if (bearerToken != null) {
            headerParameters['Authorization'] = `Bearer ${bearerToken}`;
        } else if (authNames.indexOf('OAuth') >= 0 && clientId && clientSecret) {
            let scopes = this.standardizeScopes(requiredScopes);
            let accessToken = this.getOAuthAccessToken(scopes);
            if (!accessToken) {
                await this.updateOAuthAccessToken(scopes, null);
                accessToken = this.getOAuthAccessToken(scopes);
            }
            headerParameters['Authorization'] = `Bearer ${accessToken}`;
        } else if (username != null && password != null) {
            headerParameters['Authorization'] = this.createBasicAuthHeader(username, password);
        }
    }

    private getOAuthAccessToken(scopes): string | null {
        const tokenMetadata = this.accessTokenMap.get(scopes);
        if (tokenMetadata) {
            const { accessToken, expiry } = tokenMetadata;
            const expirationTime = Math.floor(Date.now() / 1000) + 300;
            if (expirationTime < expiry) {
                return accessToken;
            }
        }
        return null;
     }

    private async updateOAuthAccessToken(scopes, accessToken) {
        const currentAccessToken = this.getOAuthAccessToken(scopes);
        // If the current access token is not set, or the cached token equals the token passed in 
        // (which will only be passed in, in the event the token failed due to being invalid or some other failure scenario)
        if (!currentAccessToken || currentAccessToken === accessToken) {
            try {
                const data = await this.buildOAuthRequest(scopes);
                let timestamp = Math.floor(Date.now() / 1000) + data['expires_in'];
                this.accessTokenMap.set(scopes, { accessToken: data['access_token'], expiry: timestamp });
            } catch (err) {
                console.log(`OAuth2 Token retrieval failed. Error: ${err}`);
                throw new Error(`OAuth2 Token retrieval failed. Error: ${err}`);
            }
        }
     }

    private async buildOAuthRequest(scopes: string) {
        const { openIdConnectUrl, clientId, clientSecret } = this.configuration;
        await this.populateTokenUrl(openIdConnectUrl);
        const response = await fetch(this.tokenUrl, {
            method: 'POST',
            body: `grant_type=client_credentials&scope=${scopes}`,
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Authorization': this.createBasicAuthHeader(clientId, clientSecret), 
                'Accept': 'application/json'
            }
        }).then(res => {
            return res.json();
        });
        return response;
     }

    private async populateTokenUrl(openIdConnectUrl: string) {
        const { environment, testTokenUrl } = this.configuration;
        if(environment === AvaTaxEnvironment.Test ) {
            this.tokenUrl = testTokenUrl;
        } else if (this.tokenUrl == null || this.tokenUrl.length == 0) {
            const tokenUrlResponse = await this.getTokenUrl(openIdConnectUrl);
            this.tokenUrl = tokenUrlResponse.token_endpoint;
        }
    }

     private async getTokenUrl(openIdConnectUrl: string) {
        let response = await fetch(openIdConnectUrl);
        let decoded = await response.json() as IOpenIdConnectURLs;
        return decoded;
     }

    private createBasicAuthHeader(username: string, password: string): string {
        const base64Encoded = Buffer.from(`${username}:${password}`).toString(
            'base64'
        );
        return `Basic ${base64Encoded}`;
    }

    private standardizeScopes(requiredScopes: string): string {
        const strArr = requiredScopes.split(' ');
        strArr.sort();
        return strArr.join(' ');
    }

    private createFetchParams(context: RequestOpts, initOverrides?: RequestInit) {
        let url = this.configuration.basePath + context.path;
        if (context.query !== undefined && Object.keys(context.query).length !== 0) {
            // only add the querystring to the URL if there are query parameters.
            // this is done to avoid urls ending with a "?" character which buggy webservers
            // do not handle correctly sometimes.
            url += '?' + this.configuration.queryParamsStringify(context.query);
        }
        const body = ((typeof FormData !== "undefined" && context.body instanceof FormData) || context.body instanceof URLSearchParams || isBlob(context.body))
        ? context.body
        : JSON.stringify(context.body);
        // timeout logic
        const controller = new AbortController();
        const timeout = this.configuration.timeout || 1200;
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        const headers = Object.assign({}, this.configuration.headers, context.headers);
        const { appName, appVersion, machineName } = this.configuration;
        headers['X-Avalara-Client'] = `${appName}; ${appVersion}; JavascriptSdk; ${this.sdkVersion}; ${machineName}`
        const init: RequestInit = {
            method: context.method,
            headers,
            body,
            signal: controller.signal,
            ...initOverrides
        };
        return { url, init, timeoutId };
    }

    private fetchApi = async (url: RequestInfo, init?: RequestInit) => {
        let fetchParams = { url, init };
        for (const middleware of this.middleware) {
            if (middleware.pre) {
                fetchParams = await middleware.pre({
                    fetch: this.fetchApi,
                    ...fetchParams,
                }) || fetchParams;
            }
        }
        
        let response = await fetch(fetchParams.url, fetchParams.init);
        for (const middleware of this.middleware) {
            if (middleware.post) {
                response = await middleware.post({
                    fetch: this.fetchApi,
                    url: fetchParams.url,
                    init: fetchParams.init,
                    response: response.clone(),
                }) || response;
            }
        }
        return response;
    }

    /**
     * Create a shallow clone of `this` by constructing a new instance
     * and then shallow cloning data members.
     */
    private clone<T extends ApiClient>(this: T): T {
        const constructor = this.constructor as any;
        const next = new constructor(this.configuration);
        next.middleware = this.middleware.slice();
        return next;
    }
};

export class RequiredError extends Error {
    name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

export type FetchAPI = typeof fetch;

export interface TokenMetadata {
    accessToken: string;
    expiry: number;
}

export interface ConfigurationParameters {
    testBasePath?: string; // override base path when using the test environment
    testTokenUrl?: string // override token URL for OAuth 2.0 flows when using the test environment
    // fetchApi?: FetchAPI; // override for fetch implementation
    middleware?: Middleware[]; // middleware to apply before/after fetch requests
    queryParamsStringify?: (params: HTTPQuery) => string; // stringify function for query strings
    username?: string; // parameter for basic security
    password?: string; // parameter for basic security
    bearerToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string | Promise<string>); // parameter for oauth2 security
    headers?: HTTPHeaders; //header params we want to use on every request
    appName: string; // Specify the name of your application here.  Should not contain any semicolons.
    appVersion: string; // Specify the version number of your application here.  Should not contain any semicolons.
    machineName: string; // Specify the machine name of the machine on which this code is executing here.  Should not contain any semicolons.
    environment: AvaTaxEnvironment; // Indicates which server to use.
    clientId?: string; // The ClientId used for the OAuth2 Client Credentials flow
    clientSecret?: string; // The ClientSecret used for the OAuth2 Client Credentials flow
    timeout?: number; // Specify the timeout for AvaTax requests in seconds; default value 20 minutes.
}

export class Configuration {
    constructor(private configuration: ConfigurationParameters) {}

    get basePath(): string {
        const { environment, testBasePath } = this.configuration;
        let basePath = '';
        if (environment === AvaTaxEnvironment.Sandbox || environment === AvaTaxEnvironment.QA) {
            basePath = 'https://sandbox-rest.avatax.com';
         } else if (environment === AvaTaxEnvironment.Production) {
            basePath = 'https://rest.avatax.com';     
         } else if (environment === AvaTaxEnvironment.Test) {
            if (!testBasePath) {
                throw new Error('TestBasePath must be configured to run in test environment mode.');
            }
            basePath = testBasePath; 
         } else {
            throw new Error('Environment not configured correctly, Acceptable values are "production", "sandbox", and "test".');
         }
        return basePath;
    }

    get openIdConnectUrl(): string {
        const { environment } = this.configuration;
        switch (environment) {
            case AvaTaxEnvironment.Production:
                return PRODUCTION_OPENID_CONFIG_URL;
            case AvaTaxEnvironment.Sandbox:
                return SANDBOX_OPENID_CONFIG_URL;
            case AvaTaxEnvironment.QA:
                return QA_OPENID_CONFIG_URL;
         }
    }

    get middleware(): Middleware[] {
        return this.configuration.middleware || [];
    }

    get queryParamsStringify(): (params: HTTPQuery) => string {
        return this.configuration.queryParamsStringify || querystring;
    }

    get appName(): string {
        return this.configuration.appName;
    }

    get appVersion(): string {
        return this.configuration.appVersion;
    }

    get machineName(): string {
        return this.configuration.machineName;
    }

    get username(): string | undefined {
        return this.configuration.username;
    }

    get password(): string | undefined {
        return this.configuration.password;
    }

    get clientId(): string {
        return this.configuration.clientId;
    }

    get clientSecret(): string {
        return this.configuration.clientSecret;
    }

    get timeout(): number {
        return this.configuration.timeout || 20;
    }

    get bearerToken(): ((name?: string, scopes?: string[]) => string | Promise<string>) | undefined {
        const { bearerToken } = this.configuration;
        if (bearerToken) {
            return typeof bearerToken === 'function' ? bearerToken : async () => bearerToken;
        }
        return undefined;
    }

    get headers(): HTTPHeaders | undefined {
        return this.configuration.headers;
    }

    get environment(): AvaTaxEnvironment {
        return this.configuration.environment;
    }

    get testTokenUrl(): string {
        return this.configuration.testTokenUrl;
    }
}

export type Json = any;
export type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS' | 'HEAD';
export type HTTPHeaders = { [key: string]: string };
export type HTTPQuery = { [key: string]: string | number | null | boolean | Array<string | number | null | boolean> | HTTPQuery };
export type HTTPBody = Json | FormData | URLSearchParams;
export type ModelPropertyNaming = 'camelCase' | 'snake_case' | 'PascalCase' | 'original';

export interface FetchParams {
    url: string;
    init: RequestInit;
}

export interface RequestOpts {
    path: string;
    method: HTTPMethod;
    headers: HTTPHeaders;
    query?: HTTPQuery;
    body?: HTTPBody;
}

export function exists(json: any, key: string) {
    const value = json[key];
    return value !== null && value !== undefined;
}

export function querystring(params: HTTPQuery, prefix: string = ''): string {
    return Object.keys(params)
        .map((key) => {
            const fullKey = prefix + (prefix.length ? `[${key}]` : key);
            const value = params[key];
            if (value instanceof Array) {
                const multiValue = value.map(singleValue => encodeURIComponent(String(singleValue)))
                    .join(`&${encodeURIComponent(fullKey)}=`);
                return `${encodeURIComponent(fullKey)}=${multiValue}`;
            }
            if (value instanceof Date) {
                return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
            }
            if (value instanceof Object) {
                return querystring(value as HTTPQuery, fullKey);
            }
            return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
        })
        .filter(part => part.length > 0)
        .join('&');
}

export function mapValues(data: any, fn: (item: any) => any) {
  return Object.keys(data).reduce(
    (acc, key) => ({ ...acc, [key]: fn(data[key]) }),
    {}
  );
}

export function canConsumeForm(consumes: Consume[]): boolean {
    for (const consume of consumes) {
        if ('multipart/form-data' === consume.contentType) {
            return true;
        }
    }
    return false;
}

export interface Consume {
    contentType: string
}

export interface RequestContext {
    fetch: FetchAPI;
    url: RequestInfo;
    init: RequestInit;
}

export interface ResponseContext {
    fetch: FetchAPI;
    url: RequestInfo;
    init: RequestInit;
    response: Response;
}

export interface Middleware {
    pre?(context: RequestContext): Promise<FetchParams>;
    post?(context: ResponseContext): Promise<Response>;
}

export interface ApiResponse<T> {
    raw: Response;
    value(): Promise<T>;
}

export interface ResponseTransformer<T> {
    (json: any): T;
}

export interface IOpenIdConnectURLs {
    "token_endpoint": string
}

export class JSONApiResponse<T> {
    constructor(public raw: Response, private transformer: ResponseTransformer<T> = (jsonValue: any) => jsonValue) {}

    async value(): Promise<T> {
        return this.transformer(await this.raw.json());
    }
}

export class VoidApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<void> {
        return undefined;
    }
}

export class BlobApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<Blob> {
        return await this.raw.blob();
    };
}

export class TextApiResponse {
    constructor(public raw: Response) {}

    async value(): Promise<string> {
        return await this.raw.text();
    };
}

export enum AvaTaxEnvironment {
    Production = 'prod',
    Sandbox = 'sandbox',
    Test = 'test',
    QA = 'qa'
}
